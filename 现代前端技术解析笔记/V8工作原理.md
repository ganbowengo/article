<!--
 * @Descripttion: 
 * @Author: ganbowen
 * @Date: 2019-12-09 15:11:32
 * @LastEditors: ganbowen
 * @LastEditTime: 2019-12-09 20:15:18
 -->
##### 语言类型
1. 在使用之前就要确认变量类型的语言称为静态语言，Java，Go，C等
2. 在运行过程中需要检查数据类型的语言称为动态语言，JavaScript、Python、PHP等
3. 支持隐式类型转换的语言称为弱类型语言
4. 不支持隐式类型转换的语言称为强类型语言
5. 编译型语言在程序执行前需要经过编译器的编译过程，转为机器能读取的二进制文件，运行程序就直接运行二进制文件，不需要再次编译。C、C++等
6. 解释型语言每次运行时都需要解释器对程序进行动态解释（编译过程）和执行。JavaScript等
> JavaScript属于弱类型动态解释型语言
##### 数据存储
**内存模型**：JavaScript执行过程中，分为三种内存空间：代码空间，栈空间，堆空间，栈空间和堆空间的区分是因为JavaScript引擎是通过栈来切换执行上下文的，如果所有的数据都放在栈中，会影响执行上下文的切换效率，进而影响整个程序的切换效率。栈空间都不会设置太大，通常只存储较小的原始数据值，堆空间很大，能存储较多的大数据。
1. 栈空间
原始类型的数据值都存在与栈空间中，空间较小，方便执行上下文的切换。
2. 堆空间
引用类型的值都存放在堆中，通过栈空间的引用地址来访问堆中的数据。
> **从内存模型的角度分析闭包**：当JavaScript引擎执行到`A函数`的时候，会创建`A函数`的空的执行上下文，开始编译代码，在编译过程中遇到`A函数`的`内部函数B`，此时会快速的词法扫描`内部函数B`，`内部函数B`引用`A函数`中的变量`c`，因为是内部函数引用了外部函数的变量`c`，则JavaScript引擎判断当前是一个闭包，会在堆空间中创建一个`closure(A)`的对象，将`c`保存到`closure(A)`对象中，当`A函数`的执行上下文销毁时，`closure(A)`还存在与堆中，`内部函数B`的执行上下文维持了对`closure(A)`的引用。

> **产生闭包的核心**：1.预扫描内部函数 2.把内部函数引用的变量保存到堆中。

##### 垃圾回收
**栈空间回收**：调用栈创建的同时，会有一个记录当前执行状态的指针（称为 ESP），指向调用栈中的栈顶的执行上下文，当栈顶的执行上下文执行完成后，ESP下移，栈顶的执行上下文空间会被下一执行上下文覆盖。

**堆空间回收**：V8会将堆分为新生代（副垃圾回收器）和老生代（主垃圾回收器），新生代存储生存时间短的对象，老生代存储生存时间久的对象

垃圾回收器的执行流程：
1. 标记空间中的活动对象（在使用）和非活动对象（可以回收）。
2. 回收非活动对象所占据的内存。
3. 内存整理，回收对象之后，堆空间会存在不连续的空间（内存碎片），如果要分配大量连续内存空间时，就会导致内存不足，需要将内存碎片整理。

新生代（副垃圾回收器）的工作流程，scavenge算法：
1. 新生代分为对象区域和空闲区域，当对象区域快要被写满时，就会执行一次垃圾清理操作，先将对象区域进行标记，标记完成，进入清理阶段，副垃圾回收器会将活动对象复制到空闲区域，并有序排列（内存整理）
2. 将空闲区域与对象区域进行角色互换，这样就完成了新生代的垃圾回收。
> 新生代中采用的 Scavenge 算法，所以每次执行清理操作时，都需要将存活的对象从对象区域复制到空闲区域。但复制操作需要时间成本，如果新生区空间设置得太大，那么每次清理的时间就会过久，所以为了执行效率，一般新生区的空间会被设置得比较小。同时JavaScript引擎采用了**对象晋升策略**，也就是经过两次垃圾回收依然还存活的对象，会被移动到老生代中。

老生代（主垃圾回收器）的工作流程，标记 - 清除（Mark-Sweep）、标记 - 整理（Mark-Compact）两种算法：
1. 标记 - 清除（Mark-Sweep），在ESP指针变化时，遍历调用栈，将未被引用的对象设置为非活动对象。
2. 标记 - 整理（Mark-Compact），标记完成之后，将活动对象向一端移动，然后清理掉端边界之外的内存。
> 为了降低老生代的垃圾回收大数据时造成的卡顿，V8 将标记过程分为一个个的子标记过程，同时让垃圾回收标记和 JavaScript 应用逻辑交替进行，直到标记阶段完成，即增量标记（Incremental Marking）算法，将一个垃圾回收任务划分为若干小任务，在其他JavaScript任务中穿插执行。

##### 代码执行
1. 将源代码转为抽象语法树（AST），并生成执行上下文。
**AST生成过程**：
- 词法分析，将一行行的源代码拆解成Token，即语法上不可能在此拆分的最小单个字符或字符串。
- 语法分析，将Token根据语法规则转换为AST
2. 生成字节码：字节码就是介于AST与机器码之间的一种代码，AST通过`解释器`生成字节码，字节码需要通过`解释器`将其装换为机器码后才能执行。
3. 执行代码：执行代码的过程中，如果遇到多次执行的代码，则将其称为热点代码，通过`编译器`把当前的热点代码转为机器码保存起来，下次再此执行的时候，直接运行机器码，无需编译，提高效率，这种技术可以称为即时编译（JIT），字节码+JIT。