#### 动态规划 (dynamic programming)

**基本思想**：
1.有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。


**过程**：
- 1、根绝问题所求的那一项和变量的个数，确定是一维数组，二维数组或者多维数组。
- 2、写出初始值，一般是某个变量为1或者0 的特殊情况时候的解。
- 3、通过循环，一般是两个循环中间每一层循环表示一个变量的递增情况。
- 4、在循环中间写出对应的递推关系表达式，求出问题的每一项。
- 5、根据题意得到答案，一般是数组的最后一项。

**常见问题**：
1.计数
- 有多少种方式走到右下角
- 有多少种方式选出K个数使得和是Sum
2.求最值
- 从左上角到右下角路径的最大数字和
- 最长上升子序列
3.存在性
- 取石子游戏 先手是否必胜
- 能不能选出k个数组成Sum

**复杂度**：
- 时间复杂度O(n^2)
- 空间复杂度O(1)


**解题思路**：
1.一般可以利用递归来解
2.通过递归找到递推关系
3.找到递归的出口
4.获得结果

```
    // 在一个数组中选择不相邻的数可以组成的最大值 假设数组元素都为正整数
    /**
    * 有两种方式 -> 递推关系
    *      选择第 n 个数
    *          f(n) = f(n-2) + arr[n]
    *      不选择第 n 个数
    *          f(n) = f(n-1)
    * 结束条件 n = 0 -> arr[0]
    *         n = 1 -> max(arr[0], arr[1])
    */

    // 递归解法
    function rec_opt(arr, n) {
        if (n === 0) return arr[0]
        else if (n === 1) return Math.max(arr[0], arr[1])
        else {
            let a = rec_opt(arr, n - 2) + arr[n]
            let b = rec_opt(arr, n - 1)
            return Math.max(a, b)
        }
    }

    // 动态规划解法
    function dp_opt(arr) {
        let l = arr.length
        let result = new Array(l).fill(0)
        // 初始值
        result[0] = arr[0] 
        result[1] = Math.max(arr[0], arr[1])
        for (let i = 2; i < l; i++) {
            // 条件判断 递推关系
            let a = result[i - 2] + arr[i]
            let b = result[i - 1]
            result[i] = Math.max(a, b)
        }
        return result[l - 1]
    }

    let a = [1, 2, 4, 2, 3]
    console.log('dp_opt(a)', dp_opt(a))
    console.log('dp_opt(a)', rec_opt(a, a.length - 1))

    // 判断数组中是否存在可以组成9的数 假设数组元素都为正整数
    
   
```

**总结**：

#### 学习资料
- [优质动态规划视频 - need vpn](https://www.youtube.com/watch?v=Jakbj4vaIbE)